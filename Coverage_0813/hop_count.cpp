// Class automatically generated by Dev-C++ New Class wizard

#include "hop_count.h" // class's header file


// class constructor
hop_count::hop_count(class deploy_map *map)
{
    msc_map = map;
    row = msc_map->Get_row();
    col = msc_map->Get_col();

    component_id = new int **[row];
    for(int i=0,id=1;i<row;i++){
        component_id[i] = new int *[col];
        for(int j=0;j<col;j++){ 
            component_id[i][j] = new int[6];
            component_id[i][j][0] = msc_map->Is_deploy(i,j) ? id ++: 0 ;
            for(int k=1;k<6;k++){component_id[i][j][k]=0;}
        }
    }


        for(int i=0,id=1;i<row;i++)
        for(int j=0;j<col;j++)
                if(msc_map->Is_deploy(i,j) && component_id[i][j][0] >= id){
                    BFS(i*col+j,id++);
                }

}

// class destructor
hop_count::~hop_count()
{
    for(int i=0;i<row;i++)
        delete [] component_id[i];
	delete [] component_id;
}
void hop_count::BFS(int root,int id){
    bool *visited = new bool[row*col];

    for(int i=0;i<row*col;i++) visited[i]= false;
    visited[root] = true;

    queue<int> q;
    q.push(root);


    while(!q.empty()){
        int v     = q.front();
        component_id[v/col][v%col][0]=id;
        q.pop();
        set<int>::iterator p;
        for(p = n_table->n_list[v].begin();
            p!= n_table->n_list[v].end();p++)
            if(msc_map->Is_deploy(*p/col,*p%col) && !visited[*p]){
                q.push(*p);
                visited[*p]=true;
            }
    }

    delete [] visited;
}
void hop_count::Main_Method(){
    int component_num=0;
    int ***back_track=new int **[row];
    int **pre_component_id=new int*[row];

    for(int i=0;i<row;i++){
            back_track[i]=new int *[col];
            pre_component_id[i]=new int [col];
            for(int j=0;j<col;j++)
                back_track[i][j]=new int[6];
    }
    for(int i=0;i<row;i++)
    for(int j=0;j<col;j++){
        if(component_id[i][j][0]>component_num)
            component_num=component_id[i][j][0];
    }

    while(component_num != 1 ){
        for(int i=0;i<row;i++)           
        for(int j=0;j<col;j++)
        for(int k=0;k<6;k++)
            back_track[i][j][k]=i*col+j;
       
        while(!Broadcast_one_hop(back_track,pre_component_id));

        component_num=Connect_componet(back_track,pre_component_id,component_num);
/*
        cout<<endl;
        for(int i=0;i<row;i++){    
            for(int j=0;j<col;j++){
                if(component_id[i][j][0]==0) cout<<"   ";
                else{
                    int color=component_id[i][j][0]>0 ? component_id[i][j][0] : -component_id[i][j][0];
                    Set_Color(color,color*5);
                    cout << setw(2) <<component_id[i][j][0];
                    Set_Color(7,0);
                    cout <<" ";
                }
            }
            cout<<endl;
        }
    
        system("PAUSE");
*/

    }//當component 只剩一個時停止
    
    for(int i=0;i<row;i++){
        delete [] back_track[i];
        delete [] pre_component_id[i];
    }
    delete [] back_track;
    delete [] pre_component_id;

}
int  hop_count::Broadcast_one_hop(int ***back_track,int **pre_component_id){ 
    int flag=0;
    for(int i=0;i<row;i++)
    for(int j=0;j<col;j++)
        pre_component_id[i][j]=component_id[i][j][0];
       
    //Broadcast 一層
    for(int i=0;i<row;i++)
    for(int j=0;j<col;j++){
        if(pre_component_id[i][j]!=0){
            int pre_num = -abs(pre_component_id[i][j]);
            set<int>::iterator p;
            for(p = n_table->n_list[i*col+j].begin();   // list the neighbor of node(i,j)
                p!= n_table->n_list[i*col+j].end();p++){
                if(component_id[*p/col][*p%col][0] == 0){
                    component_id[*p/col][*p%col][0]= pre_num;
                    back_track[*p/col][*p%col][0]= i*col+j;
                }
                else if(component_id[*p/col][*p%col][0]!=  pre_component_id[i][j] &&
                        component_id[*p/col][*p%col][0]!= -pre_component_id[i][j] ){                    //交集處理
                    int k=0;
                    while( !(component_id[*p/col][*p%col][++k] == pre_num || !component_id[*p/col][*p%col][k]) );
                    component_id[*p/col][*p%col][k]= pre_num;
                    back_track[*p/col][*p%col][k]= i*col+j;
                    flag=1;
                }
            }
        }
    }

    return flag;
    
}
int hop_count::Connect_componet(int ***back_track,int **pre_component_id,int component_num){

    int c_x,c_y,c_num;

    for(int k=5 ; k>=0 ;k--){
        bool flag = false;
        for(int i=0;i<row;i++)
        for(int j=0;j<col;j++)
            if(component_id[i][j][k]!=0){
                c_x=i;c_y=j;c_num=k;
                flag = true;
                if(pre_component_id[i][j]!=0){

                    goto Loop_Exit;
                }
            }
        if(flag) break;
    }
    Loop_Exit: ;

    int id= -component_id[c_x][c_y][0];

    for(int k=0;k<=c_num;k++){
        int l,replace_id = -component_id[c_x][c_y][k],p = c_x*col+c_y;      

        while(1){    
            for(l=0;l<6;l++)
                if(component_id[p/col][p%col][l] == -replace_id ||
                   component_id[p/col][p%col][l] == replace_id) 
                   break;
            if(p==back_track[p/col][p%col][l]) break;
            component_id[p/col][p%col][0] = replace_id;
            msc_map->deploy_sensor(p/col,p%col);
            p=back_track[p/col][p%col][l];            
        }
        if(replace_id != id){
            for(int i=0;i<row;i++)    
            for(int j=0;j<col;j++)
                if(component_id[i][j][0]== replace_id){
                    component_id[i][j][0]=id;
                }
        }
    }

   
    component_num = component_num - c_num ;

    ReSet_component_id();

    return component_num;
}
void hop_count::ReSet_component_id(){
    for(int i=0;i<row;i++)    
    for(int j=0;j<col;j++){    
        if(component_id[i][j][0] < 0)
            component_id[i][j][0]=0;
    for(int k=1;k<6;k++)    component_id[i][j][k]=0;
    }
}
class deploy_map* hop_count::Get_hop_map(){
    return msc_map;
}
