// Class automatically generated by Dev-C++ New Class wizard

#include "neighbor_table.h" // class's header file

// class constructor
neighbor_table::neighbor_table(int ROW,int COL,double rs,double rt,Grid* critical,bool flag)
{
    IsObstacle=flag;
    row=ROW;col=COL;
    RS=rs;RT=rt;
    map = critical;
    Construct_neighbor_table();
}
// class destructor
neighbor_table::~neighbor_table()
{
	delete [] n_list;
    delete [] c_list;
}

void neighbor_table::Construct_neighbor_table(){
    n_list = new set<int> [row*col];
    c_list = new set<int> [row*col];
    for(int i=0;i<row;i++)
    for(int j=0;j<col;j++){
            if(!map->IsLink(i,j)) continue;

            int bound = (int)ceil(RT);
            int u_bound = ( i - bound ) >= 0  ? (i - bound): 0    ;
            int d_bound = ( i + bound ) < row ? (i + bound): row-1;
            int l_bound = ( j - bound ) >= 0  ? (j - bound): 0    ;   
            int r_bound = ( j + bound ) < col ? (j + bound): col-1; 

            for(int x=u_bound;x<=d_bound;x++)                      //for all grid q
            for(int y=l_bound;y<=r_bound;y++){
                if(Is_P_neighbor(i,j,x,y)){
                    n_list[i*col+j].insert(x*col+y);                

                }
            }
            
            bound = (int)ceil(RS);
            u_bound = ( i - bound ) >= 0  ? (i - bound): 0    ;
            d_bound = ( i + bound ) < row ? (i + bound): row-1;
            l_bound = ( j - bound ) >= 0  ? (j - bound): 0    ;   
            r_bound = ( j + bound ) < col ? (j + bound): col-1; 
            //printf("(%d,%d)\n",i,j);     
            for(int x=u_bound;x<=d_bound;x++)                      //for all grid q
            for(int y=l_bound;y<=r_bound;y++){       
                if(Compute_cover_grid(i,j,x,y)==15)
                   c_list[i*col+j].insert(x*col+y);

            }
    }

  /*  for(int i=0;i<row;i++)
    for(int j=0;j<col;j++){
        set<int>::iterator p;
        if(c_list[i*col+j].empty()) continue;
        printf("\n%d,%d:\t",i,j);
        for(p = c_list[i*col+j].begin();
            p!= c_list[i*col+j].end();p++){
            printf("(%d,%d) ",*p/col,*p%col);
        }
    }*/
    
}
bool neighbor_table::Is_P_neighbor(int p_x,int p_y,int q_x,int q_y){
    bool reVal;

    if(p_x == q_x && p_y == q_y) return false;
    if(!map->IsLink(p_x,p_y)|| !map->IsLink(q_x,q_y)) return false;
    double distance =  pow(pow((double)(p_x-q_x),2.0)+( pow((double)(p_y-q_y),2.0)),0.5);

    reVal=(distance <= RT) ? true : false;
    if(IsObstacle && reVal){
        reVal = Is_Sight(p_x,p_y,q_x,q_y);
    }    

    return reVal;
}
int  neighbor_table::Compute_cover_grid(int p_x,int p_y,int q_x,int q_y){
    int num=0,index=1;
   // printf("\t(%d,%d):\t",q_x,q_y);
    for(double k = (-0.5); k<=0.5 ; k++)
    for(double l = (-0.5); l<=0.5 ; l++,index*=2){
        double distance =  pow((double)((q_x+k)-p_x),2.0)+( pow((double)((q_y+l)-p_y),2.0));
        if(distance <= RS*RS ){
            if(distance >= 1 && IsObstacle && !Is_Sight(p_x,p_y,q_x+k,q_y+l) ){ 
              //  printf("%.1lf,%.1lf\t",q_x+k,q_y+l);     
                continue;
            }
            num=num+index;
        }
    }    
   // printf("\n");
   // if(num != 15) system("PAUSE");
    return num;
}
bool neighbor_table::Is_Sight(double p_x,double p_y,double q_x,double q_y){
    bool reVal=true;
    double temp;
    double min_x,min_y;
    double max_x,max_y; 

    if(p_y >  q_y ){ 
        min_x = q_x;   min_y = q_y;
        max_x = p_x;   max_y = p_y; 
    }
    else{
        min_x = p_x;   min_y = p_y;
        max_x = q_x;   max_y = q_y;
    }     
//    for(int i_y=(int)floor(min_y) ; i_y+0.5<max_y ; i_y++){
    for(int i_y=(int)min_y ; i_y+0.5<max_y ; i_y++){

        double obst_y = i_y+0.5;
        double obst_x = min_x+((obst_y-min_y)*(max_x-min_x)/(max_y-min_y));
        double fract  = modf(obst_x,&temp);
        int i_x =  fract>0.5 ? (int)ceil(obst_x): (int)floor(obst_x);

        if( i_y <0 || i_x < 0 || obst_y== min_y){continue;}

        if( fract!= 0.5 && map->IsVert(i_x,i_y)){       // 判斷一面直牆
           reVal = false;
           break;
        }
        if(fract == 0.5){                                                                   //切角落時 
            int in_angle_x = (min_x < max_x )? i_x : i_x+1 ;                                   
            int out_angle_x = (min_x < max_x )? i_x+1 : i_x ;                                   
//            if( i_x+1 < row && map->IsVert(i_x,i_y) && map->IsVert(i_x+1,i_y)){          // 判斷兩面直牆
            if( (i_x+1 < row && map->IsVert(i_x,i_y) && map->IsVert(i_x+1,i_y))     ||          // 判斷兩面直牆
                ( map->IsVert(in_angle_x,i_y) && map->IsHori(i_x,i_y)) ||
                ( map->IsVert(out_angle_x,i_y) && map->IsHori(i_x,i_y+1))){  // 判斷直角
                reVal = false;
                break;                            
            }
        }
   // printf("\t(%d,%d)=y=(%2.1lf,%2.1lf)\n",i_x,i_y,obst_x,obst_y);
    }

    if(p_x >  q_x ){ 
        min_x = q_x;   min_y = q_y;
        max_x = p_x;   max_y = p_y; 
    }
    else{
        min_x = p_x;   min_y = p_y;
        max_x = q_x;   max_y = q_y;
    }
//    for(int i_x=(int)floor(min_x) ; i_x+0.5<max_x ; i_x++){
    for(int i_x=(int)min_x ; i_x+0.5<max_x ; i_x++){

        double obst_x = i_x+0.5;
        double obst_y = min_y+((obst_x-min_x)*(max_y-min_y)/(max_x-min_x));
        double fract  = modf(obst_y,&temp);
        int i_y =  fract>0.5 ? (int)ceil(obst_y): (int)floor(obst_y);


        if( i_y <0 || i_x < 0 || obst_x == min_x){continue;}
        if( fract!= 0.5 && map->IsHori(i_x,i_y)){
           reVal = false;
           break;
        }

        if(fract == 0.5){                                                                   //切角落時 
            int angle_y = (min_y < max_y )? i_y : i_y+1 ;                                   
            if( i_y+1<col && map->IsHori(i_x,i_y) && map->IsHori(i_x,i_y+1)) {          // 判斷兩面直牆
//            if( (i_y+1<col && map->IsHori(i_x,i_y) && map->IsHori(i_x,i_y+1)) ||          // 判斷兩面直牆
            //    (angle_y<col && map->IsVert(i_x,angle_y) && map->IsHori(i_x,i_y)) ){  // 判斷直角
                reVal = false;
                break;                            
            }
        }
  //  printf("\t(%d,%d)=x=(%2.1lf,%2.1lf)\n",i_x,i_y,obst_x,obst_y);
    }

    return reVal;
}
