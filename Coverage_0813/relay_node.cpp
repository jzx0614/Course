// Class automatically generated by Dev-C++ New Class wizard

#include "relay_node.h" // class's header file

// class constructor
Relay_node::Relay_node(class deploy_map *map)
{
    d_map = map;
    row = d_map->Get_row();
    col = d_map->Get_col();

    length = new int *[d_map->sensor_num];      //initial deploy-map node to node length
    for(int i=0;i<d_map->sensor_num;i++){
        length[i]= new int [d_map->sensor_num];
        for(int j=0;j<d_map->sensor_num;j++)
        length[i][j]=0;
    }

    node_id = new int [d_map->sensor_num];      //initial node -> id change array 
    for(int i=0,k=0;i<row;i++)
    for(int j=0;j<col;j++){
        if(d_map->Is_deploy(i,j))
            node_id[k++]=i*col+j;
    }
}

// class destructor
Relay_node::~Relay_node()
{
//    for(int i=0;i<d_map->sensor_num;i++)
//        delete [] length[i];
	delete [] length;
    delete [] node_id;
}

void Relay_node::Construct_adjacency_matrix(){
    for(int i=0;i<d_map->sensor_num;i++){
        BFS(node_id[i]);
    }
}
int Relay_node::Find_node_id(int node){
   for(int i=0;i<d_map->sensor_num;i++){
        if(node_id[i]==node)
            return i;
   } 
   return -1;
}
void Relay_node::BFS(int root){
    bool *visited = new bool[row*col];
    int id_1=Find_node_id(root);

    for(int i=0;i<row*col;i++) visited[i]= false;
    visited[root] = true;

    queue<int> q,d;
    q.push(root);       //node id queue
    d.push(0);          //node depth queue

    while(!q.empty()){
        int v     = q.front();
        int depth = d.front();
        if(d_map->Is_deploy(v/col,v%col)){
            int id_2=Find_node_id(v);
            length[id_1][id_2]=depth;
        }
        q.pop();
        d.pop();
        set<int>::iterator p;
        for(p = n_table->n_list[v].begin();
            p!= n_table->n_list[v].end();p++)
            if(!visited[*p]){
                q.push(*p);
                d.push(depth+1);
                visited[*p]=true;
            }
    }

    delete [] visited;
}
// Construct Minimum Spanning Tree
void Relay_node::MST(){         
    set<int> node_set,T_vertex;
    for(int i=0;i<d_map->sensor_num;i++){
        node_set.insert(i);
    }
    T_vertex.insert(0);
    node_set.erase(0);   



    while(edge_set.size()<d_map->sensor_num-1){         // egde_num == n-1   stop
        set<int>::iterator p=T_vertex.begin();
        set<int>::iterator q=node_set.begin();
        int s=*p,d=*q,min_hop=length[*p][*q];
        char temp[10];
        for(p=T_vertex.begin();p!=T_vertex.end();p++){  // Find minimum edge from tree_set to edge_set
            for(q=node_set.begin();q!=node_set.end();q++){
                if(length[*p][*q] < min_hop){
                    min_hop = length[*p][*q];
                    s = *p; d = *q;
                }            
            }
        }
        T_vertex.insert(d);                             // Add desnation
        node_set.erase(d);
        sprintf(temp,"%d-%d",s,d);
        edge_set.insert(temp);                          //save edge
    }
/*
        cout<<"\nedge_set:\n";
        set<string>::iterator iter;
        for(iter=edge_set.begin();iter!=edge_set.end();iter++)
            cout<<*iter<<" ";
        cout<<endl;*/
}
bool Relay_node::deploy_edge(int s,int d){
    int *visited = new int[row*col];

    for(int i=0;i<row*col;i++) visited[i]= -1;
    visited[node_id[s]] = node_id[s];

    queue<int> q;
    q.push(node_id[s]);

    while(!q.empty()){
        int v     = q.front();
        q.pop();

        if(v==node_id[d]){
            break;
        }

        set<int>::iterator p;
        for(p = n_table->n_list[v].begin();
            p!= n_table->n_list[v].end();p++)
            if(visited[*p]==-1){
                q.push(*p);
                visited[*p]=v;
            }
    }

    int deploy_node = visited[node_id[d]];
    while(deploy_node != node_id[s]){
        d_map->deploy_sensor(deploy_node/col,deploy_node%col);
        deploy_node = visited[deploy_node];
    }
    delete [] visited;    
}

void Relay_node::Connect_MST(){
    while(!edge_set.empty()){
        int s,d;
        set<string>::iterator iter=edge_set.begin();
        sscanf(iter->c_str(),"%d-%d",&s,&d);
        if(length[s][d] > 1 ) deploy_edge(s,d);
        edge_set.erase(*iter);
    }
}
class deploy_map * Relay_node::Get_Map(){
    return d_map;
}

