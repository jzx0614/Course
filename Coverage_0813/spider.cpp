// Class automatically generated by Dev-C++ New Class wizard

#include "spider.h" // class's header file

#define DEBUG 0
// class constructor
spider::spider(int weight)
{
    internal_weight = weight ;
}

// class destructor
spider::~spider()
{
    for(int i=0;i<graph_node_num;i++){
        delete [] graph_adj[i];
        delete [] dist[i];
        delete [] back_track[i];
    }

    delete [] graph_adj;
	delete [] i_node;
    delete [] dist;
    delete [] back_track;
}




//    07.08_13 去掉 所有 V2 vetex .
void spider::Embedded_to_Graph(class Grid *c_map)
{
    total_terminal=c_map->Get_Critical_Num();
    int internal_num=0; 
    row = c_map->Get_row();
    col = c_map->Get_col();
    map = c_map;
 
    graph_node_num = row * col + total_terminal;

    cout << row*col <<" "<< total_terminal<< " "<<graph_node_num<<endl;

    // new 左半邊三角形◣的 adj space.
    i_node = new node_inf[graph_node_num];
    graph_adj = new int *[graph_node_num];
    for(int i=0;i<graph_node_num;i++){
        graph_adj[i]= new int[i+1];
        for(int j=0;j<=i;j++)
            graph_adj[i][j]= 0 ;
    }

    // assign  weight for all node.
    for(int i=0,k=1;i<graph_node_num;i++){
        if(i<row*col){
            i_node[i].weight=1;
            i_node[i].terminal_num=0;
        }
        else if(row*col <= i && i < row*col+total_terminal ){
            i_node[i].weight=0;
            i_node[i].terminal_num=k++;   
        }
    }
    // Create terminal_id mapping to the index of i_node.
    int terminal_id[total_terminal];
    for(int i=0,k=0;i<row*col;i++)
        if(c_map->IsCritical(i/col,i%col))
            terminal_id[k++]=i;    

    for(int i=0,k=0;i<row*col;i++){
        set<int>::iterator p;
        for(p = n_table->n_list[i].begin(); //construct v1 eage
            p!= n_table->n_list[i].end();p++)
            if(*p <= i)  graph_adj[i][*p]= 1 ;
            else         graph_adj[*p][i]= 1 ;
        for(p = n_table->c_list[i].begin();     //connect v1 to terminal
            p!= n_table->c_list[i].end();p++)        
            if(c_map->IsCritical(*p/col,*p%col)){
                int j;
                for(j=0;j<total_terminal;j++)   //Find terminal_id
                    if(*p==terminal_id[j])   break;
                graph_adj[row*col+j][i]=1; 
            }                          
    }
}
// No description
class deploy_map* spider::Graph_to_Deploy()
{
    
    class deploy_map *spider_dmap= new class deploy_map(row,col);
	for(int i=0;i<row*col;i++){
        if(i_node[i].terminal_num)
            spider_dmap->deploy_sensor(i/col,i%col);
    }
/*    int tt=0;
    for(int i=row*col;i<row*col+total_terminal;i++){
        if(i_node[i].terminal_num) tt++;
    }
    int ii=0;
    for(int i=row*col+total_terminal;i<graph_node_num;i++){
        if(i_node[i].terminal_num) ii++;
    }
    cout <<"v3: "<<tt<<" v2: "<<ii<<endl;*/
    return spider_dmap;
}

// No description
void spider::Construct_AP_distance()
{

    dist = new int *[graph_node_num];
    back_track = new int *[graph_node_num];
	for(int i=0;i<graph_node_num;i++){
        dist[i] = new int[graph_node_num];
        back_track[i] = new int [graph_node_num];
        for(int j=0;j<=i;j++){
            if(graph_adj[i][j]==1){
                dist[i][j]=i_node[j].weight;  
                dist[j][i]=i_node[i].weight;        
                if(i >= row*col){
                    dist[i][j]+=internal_weight;  
                    dist[j][i]+=internal_weight;        
                }
                back_track[i][j]=i;
                back_track[j][i]=j;
            }
            else if(i==j) {
                dist[i][j]=0;
                back_track[i][j]=i;
            }
            else{
                dist[i][j]=30000;
                dist[j][i]=30000;

                back_track[i][j]=30000;
                back_track[j][i]=30000;
            }            
        }
    }

    double percent=0,now_per;
    for(int k=0;k<graph_node_num;k++){
    for(int i=0;i<graph_node_num;i++)
    for(int j=0;j<graph_node_num;j++)
        if(dist[i][j] > dist[i][k]+dist[k][j]){
            dist[i][j] = dist[i][k]+dist[k][j];
            back_track[i][j]=k;
        }
        //system("cls");
        now_per = 100*(double)k/(double)graph_node_num;
        if(now_per - percent >= 1 ){
            percent = now_per;
            printf(".. %.2lf %% ..\n",now_per);
        }
    }

    for(int i=0;i<graph_node_num;i++)
    for(int j=0;j<graph_node_num;j++)
        dist[i][j] -= i_node[j].weight;

}

void spider::search_path(int i,int j,int term){
    
    if(i!=back_track[i][j]){
        search_path(i,back_track[i][j],term);
        search_path(back_track[i][j],j,term);
    }
    else{
        i_node[i].terminal_num=term;
        if(DEBUG)cout << i<<"-";
    }
}
/*  07.08_13 找出v1連v2中,v2還沒被merge進tree中的總數
int spider::Get_v2_num(int id,int* term_num){
    int count=0;
    if(id >= row*col) return -1;

    for(int i=row*col+total_terminal;i<graph_node_num;i++){     // v2 set
        if(dist[id][i]==0){
            for(int j=row*col;j<row*col+total_terminal;j++){    // v3 set
                if(dist[i][j]==0 && term_num[i_node[j].terminal_num-1]==1)
                    count++;
            }
        }
    }

    return count;
}*/
// 07.08_13 找出v1連v3中,v3所在的tree_size為1的個數
int spider::Get_v2_num(int id,int* term_num){
    int count=0;
    if(id >= row*col) return -1;
    for(int i=row*col;i<row*col+total_terminal;i++){    // v3 set
       if(graph_adj[i][id]==1 && term_num[i_node[i].terminal_num-1]==1)
           count++;
    }
    return count;
}
void spider::Algorithm()
{
    int now_term = total_terminal;
    int term_num[total_terminal];   //每個tree有的個數
   

    while(now_term > 1){
        int rm=0,r3plus=0;
        int v2_num=0,v2_num_2=0;
        
        for(int i=0;i<total_terminal;i++)
            term_num[i]=0;

        for(int i=0;i<graph_node_num;i++){
            i_node[i].m  = 0;
            i_node[i].rm = 30000;
            i_node[i].r_plus = 30000; 
            term_num[i_node[i].terminal_num-1]++;
        }

        for(int i=0;i<graph_node_num;i++)     {   
           // if(i_node[i].terminal_num==0){
                  
                Compute_ratio(i,now_term);

                if( i_node[rm].rm > i_node[i].rm ||
                   (i_node[rm].rm == i_node[i].rm && i_node[rm].m < i_node[i].m ) ||
                   (i_node[rm].rm == i_node[i].rm && i_node[rm].m == i_node[i].m && v2_num < Get_v2_num(i,term_num) )){
                    
                    v2_num = Get_v2_num(i,term_num);
                    rm = i;
                }
                if( now_term > 2  && i_node[r3plus].r_plus>i_node[i].r_plus ||
                   (i_node[r3plus].r_plus==i_node[i].r_plus && i_node[r3plus].plus<i_node[i].plus) ||
                   (i_node[r3plus].r_plus==i_node[i].r_plus && i_node[r3plus].plus==i_node[i].plus && v2_num_2 < Get_v2_num(i,term_num))){
                   v2_num_2 = Get_v2_num(i,term_num);  
                   r3plus = i;            
                }
            //}
        }

        printf("\nmin_ratio = %lf .it's %d spider in %d. %d\n",i_node[rm].rm,i_node[rm].m,rm,v2_num); 
        printf("min_ratio = %lf .it's %d spider in %d.\n",i_node[r3plus].r_plus,i_node[r3plus].plus,r3plus);

        now_term = Contract(rm,now_term,i_node[rm].m);

        if(DEBUG){
            cout << endl;
            for(int i=0;i<row;i++){
                if(i==0) {
                    for(int j=0;j<col;j++)
                        cout << j%10 <<" ";
                    cout << endl;
                }
            }
             Graph_to_Deploy()->show_map(map);
        }      
     
        cout << "terminal_number="<<now_term << endl;

        if(DEBUG)       system("PAUSE");       
    }
}

// No description
void spider::Compute_ratio(int node_id,int terminal)
{
    double terminal_dist[total_terminal];
    for(int i=0;i<total_terminal;i++)
        terminal_dist[i]=30000;
    
    for(int i=0;i<graph_node_num;i++){
        if( i_node[i].terminal_num){    // 07.08_13 修改濾掉自己
            if(dist[node_id][i] < terminal_dist[ i_node[i].terminal_num-1 ])
                terminal_dist[i_node[i].terminal_num-1]=dist[node_id][i];    
        }
    }
    sort(terminal_dist,terminal_dist+total_terminal);


    double sum = i_node[node_id].weight+terminal_dist[0];
    for(int i=1;i<terminal;i++){
        sum += terminal_dist[i];
        double buf_rm= sum / (i+1);
        if( i_node[node_id].rm >= buf_rm ){ 
            i_node[node_id].rm = buf_rm ;
            i_node[node_id].m = i+1;
        }
        else if(i>1 && i_node[node_id].r_plus >= buf_rm){
            i_node[node_id].r_plus = buf_rm ;
            i_node[node_id].plus = i+1 ;
        }
        else 
            break;
    }                  
}

bool cmp(ratio a,ratio b){
    return a.r < b.r ;
}
int spider::Contract(int id,int terminal,int contract_num)
{    
    ratio term[total_terminal];
    for(int i=0;i<total_terminal;i++){ 
        term[i].r=30000;
        term[i].id=-1;
    }
    

    for(int i=0;i<graph_node_num;i++){
        if(i_node[i].terminal_num){     // 07.08_13 修改濾掉自己
            if(dist[id][i] < term[ i_node[i].terminal_num-1 ].r){
                term[i_node[i].terminal_num-1].r = dist[id][i];
                term[i_node[i].terminal_num-1].id= i;
            }   
        }
    }
    sort(term,term+total_terminal,cmp);   

    for(int i=1;i<contract_num;i++){
        int change_term = i_node[term[i].id].terminal_num;
        for(int j=0;j<graph_node_num;j++)
           if(i_node[j].terminal_num == change_term)
                i_node[j].terminal_num = i_node[term[0].id].terminal_num;
    }
    
	for(int i=0;i<contract_num;i++){
        search_path(id,term[i].id,i_node[term[0].id].terminal_num);
        if(DEBUG) cout <<term[i].id<<"\n";
    }

    return terminal-contract_num+1;
}


int spider::Find_forest_path(set<string> &T,double rm,double r_plus)
{
    int closest_dist[total_terminal];
    string closest_path[total_terminal];
    for(int i=0;i<total_terminal;i++){
        closest_dist[i] = 9999;
       // cout << closest_path[i] <<endl;
    }
    
    for(int i=0;i<graph_node_num;i++){
        if(i_node[i].terminal_num)
            for(int j=0;j<graph_node_num;j++)
                if(i_node[i].terminal_num != i_node[j].terminal_num &&
                   i_node[j].terminal_num   > 0                     && 
                   closest_dist[i_node[i].terminal_num-1] > dist[i][j]){
                    char temp[10];
                    if(i < j) sprintf(temp,"%d-%d",i,j);
                    else      sprintf(temp,"%d-%d",j,i);  
                    closest_path[i_node[i].terminal_num-1].assign( temp );
                    closest_dist[i_node[i].terminal_num-1] = dist[i][j];
                    
                }
    }

    double min_ratio = (4*rm/3 < r_plus) ?  4*rm/3 : r_plus ;

    
    for(int i=0;i<total_terminal;i++){
        if( closest_dist[i] <= 2 * min_ratio){
            T.insert(closest_path[i]);
        }
    }
}

// No description
int spider::Contract_Forest(set<string> T,int terminal)
{
	set<string>::iterator iter;
    int s,d,contract_node;


    for(iter = T.begin() ; iter != T.end() ; iter++){
        
        sscanf(iter->c_str(),"%d-%d",&s,&d);

if(DEBUG)        cout << s <<"->"<<d <<" "<<dist[s][d]<<" "<<i_node[s].terminal_num<<"->"<<i_node[d].terminal_num<<endl;

        search_path(s,d,i_node[s].terminal_num);
if(DEBUG)
        cout <<endl;

        int change_term = i_node[d].terminal_num;
        for(int i=0;i<graph_node_num;i++){
            if(i_node[i].terminal_num == change_term)
                i_node[i].terminal_num = i_node[s].terminal_num;
        }
    }



    bool count_term[total_terminal];
    memset(count_term,0,sizeof(bool)*total_terminal);
    for(int i=0;i<graph_node_num;i++){
        if(i_node[i].terminal_num)
            count_term[i_node[i].terminal_num-1]=true;
    }
    int t_num = 0 ;
    for(int i=0;i<total_terminal;i++){
        if(count_term[i]) t_num++; 
    }
    return  t_num;
}
